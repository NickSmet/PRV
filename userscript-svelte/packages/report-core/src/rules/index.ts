/**
 * Rule Engine
 * 
 * Central registry for all rules and the main evaluation function.
 * Rules are pure functions that take a ReportModel and return Markers.
 */

import type { Rule, RuleEvaluationResult } from './types';
import type { ReportModel } from '../types/report';
import type { Marker } from '../types/markers';
import { currentVmRules } from './currentVm';

// ============================================================================
// Rule Registry
// ============================================================================

/**
 * All rules from all categories
 */
const allRules: Rule[] = [
  ...currentVmRules,
  // Future: add more rule sets here
  // ...advancedVmRules,
  // ...hostInfoRules,
  // ...driverRules,
  // ...storageRules,
];

// ============================================================================
// Rule Evaluation
// ============================================================================

/**
 * Evaluate all rules against a report model
 * @param report The complete report model
 * @returns Array of all markers generated by the rules
 */
export function evaluateRules(report: ReportModel): Marker[] {
  const markers: Marker[] = [];
  
  for (const rule of allRules) {
    try {
      const ruleMarkers = rule(report);
      markers.push(...ruleMarkers);
    } catch (error) {
      console.warn('[PRV] Rule evaluation error:', error);
    }
  }
  
  return markers;
}

/**
 * Evaluate all rules with timing and statistics
 * @param report The complete report model
 * @returns Evaluation result with markers and metadata
 */
export function evaluateRulesWithStats(report: ReportModel): {
  markers: Marker[];
  stats: RuleEvaluationResult;
} {
  const startTime = performance.now();
  const markers = evaluateRules(report);
  const endTime = performance.now();
  
  // Group markers by node
  const markersByNode = new Map<string, number>();
  for (const marker of markers) {
    const nodeId = 'nodeId' in marker.target ? marker.target.nodeId : 'unknown';
    markersByNode.set(nodeId, (markersByNode.get(nodeId) || 0) + 1);
  }
  
  return {
    markers,
    stats: {
      totalMarkers: markers.length,
      evaluationTimeMs: endTime - startTime,
      markersByNode
    }
  };
}

/**
 * Evaluate only CurrentVm rules
 * @param report The report model (only currentVm needs to be populated)
 * @returns Array of markers for CurrentVm
 */
export function evaluateCurrentVmRules(report: ReportModel): Marker[] {
  const markers: Marker[] = [];
  
  for (const rule of currentVmRules) {
    try {
      const ruleMarkers = rule(report);
      markers.push(...ruleMarkers);
    } catch (error) {
      console.warn('[PRV] CurrentVm rule evaluation error:', error);
    }
  }
  
  return markers;
}

// ============================================================================
// Re-exports
// ============================================================================

export { currentVmRules } from './currentVm';
export type { Rule, NamedRule, RuleEvaluationResult } from './types';




